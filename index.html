<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mopedi Keulit — valmis selainpeli</title>
  <style>
    :root{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial;}
    body{margin:0;background:linear-gradient(#071024,#031022);color:#e6eef8;display:flex;align-items:center;justify-content:center;min-height:100vh}
    #wrap{width:1000px;max-width:96vw;padding:18px}
    .card{background:linear-gradient(180deg,#031425,#071827);border-radius:12px;padding:14px;box-shadow:0 12px 40px rgba(2,6,23,0.6)}
    header{display:flex;justify-content:space-between;align-items:center}
    h1{margin:0;font-size:20px}
    .controls{display:flex;gap:10px;align-items:center}
    .btn{background:#06b6d4;border:none;padding:8px 12px;border-radius:8px;color:#022c2f;font-weight:700;cursor:pointer}
    canvas{display:block;border-radius:10px;width:100%;height:520px;background:linear-gradient(#4fb2ff10,#00000040)}
    .muted{color:#93b0c4;font-size:13px}
    #mopedSelect{display:flex;gap:8px;margin-top:10px}
    .mopedCard{background:#021427;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);flex:1;cursor:pointer}
    .mopedCard.selected{outline:3px solid rgba(99,102,241,0.12)}
    .tunePanel{display:flex;gap:12px;margin-top:12px}
    .tune{background:#021427;padding:10px;border-radius:8px;flex:1}
    label{display:block;font-size:13px;margin-bottom:6px}
    input[type=range]{width:100%}
    .touch{display:none;margin-top:12px;gap:8px}
    .touch .tbtn{flex:1;padding:12px;border-radius:8px;background:#022430;text-align:center}
    @media (max-width:820px){.touch{display:flex}; #mopedSelect{flex-direction:column}}
    .small{font-size:13px;color:#93b0c4}
    .row{display:flex;gap:8px}
    .col{flex:1}
    .help{margin-top:10px;color:#bcd6ea;font-size:13px}
  </style>
</head>
<body>
  <div id="wrap">
    <div class="card">
      <header>
        <h1>Mopedi Keulit — Tuunaa, keuli & kerää pisteitä</h1>
        <div class="controls">
          <div class="small">Pisteet: <strong id="score">0</strong></div>
          <button id="restart" class="btn">Aloita / Uudelleen</button>
        </div>
      </header>

      <canvas id="game" width="960" height="520" aria-label="Mopo keula peli"></canvas>

      <div id="mopedSelect"></div>

      <div class="tunePanel">
        <div class="tune">
          <label>Mopon väri</label>
          <input id="colorPicker" type="color" value="#06b6d4">
          <label style="margin-top:8px">Pakoputki (ääniprofiili)</label>
          <select id="exhaustSelect">
            <option value="stock">Stock (hiljainen)</option>
            <option value="sport">Sport (kova)</option>
            <option value="racing">Racing (kova, korkea)</option>
          </select>
        </div>
        <div class="tune">
          <label>Tehopäivitys (vaikuttaa wheelie-multiplik.)</label>
          <input id="powerRange" type="range" min="0" max="3" step="1" value="0">
          <div class="small">Taso: <span id="powerLevel">0</span></div>
          <label style="margin-top:8px">Vakauspäivitys</label>
          <input id="stabilityRange" type="range" min="0" max="3" step="1" value="0">
          <div class="small">Taso: <span id="stabLevel">0</span></div>
        </div>
        <div class="tune">
          <label>Lisää oma ääni (valinnainen)</label>
          <input id="fileInput" type="file" accept="audio/*">
          <div class="small" style="margin-top:8px">Voit ladata .mp3/.wav tiedoston joka korvaa mopon äänen pelin aikana.</div>
          <div style="margin-top:10px">
            <button id="saveTune" class="btn">Tallenna tuunaukset</button>
            <button id="loadTune" class="btn" style="background:#9ca3ff">Palauta tallennetut</button>
          </div>
        </div>
      </div>

      <div class="touch" id="touchControls">
        <div class="tbtn" id="leftBtn">◀</div>
        <div class="tbtn" id="wheelieBtn">KEULI</div>
        <div class="tbtn" id="rightBtn">▶</div>
      </div>

      <div class="help">
        Ohjeet: Valitse mopedi, säädä väri/putki/teho. Käytä ← → tai A/D liikkumiseen. Pidä ↑ / W tai välilyöntiä keulataksesi. Takalokarin osuma maahan johtaa välittömään kaatumiseen.
      </div>

      <footer style="margin-top:12px" class="small">Tallennus: paras tulos ja tuunaukset tallennetaan paikallisesti selaimeesi.</footer>
    </div>
  </div>

<script>
/* Täydellinen päivitetty peli
   - Parannettu fysiikka: massamainen kiihtyvyys, vertikaalifysiikka ramppeja varten
   - Takalokari-osuma (rear fender) -> välitön kaatuminen
   - Parallax, partikkelit, rampit, 4 selkeää mopomallia
   - Audio: custom + synth fallback, äänen stoppaus pelin lopussa
   - Tallennus ja UI
   Kopioi tiedosto ja korvaa nykyinen index.html. Säilytä assets-kansio, jos haluat lisätä omat mp3/png-tiedostot.
*/

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI
  const scoreEl = document.getElementById('score');
  const restartBtn = document.getElementById('restart');
  const mopedSelectEl = document.getElementById('mopedSelect');
  const colorPicker = document.getElementById('colorPicker');
  const exhaustSelect = document.getElementById('exhaustSelect');
  const powerRange = document.getElementById('powerRange');
  const stabilityRange = document.getElementById('stabilityRange');
  const powerLevel = document.getElementById('powerLevel');
  const stabLevel = document.getElementById('stabLevel');
  const fileInput = document.getElementById('fileInput');
  const saveTuneBtn = document.getElementById('saveTune');
  const loadTuneBtn = document.getElementById('loadTune');

  // Mopedit: lisää "rearHeight" ja "rearHitThreshold" mallikohtaisesti
  // rearHeight = relative rear-fender height above ground (px)
  // rearHitThreshold = allowed vertical impact speed before instant crash
  const mopeds = [
    {id:'derbi', name:'Derbi Senda', color:'#06b6d4', acceleration:1400, maxSpeed:420, handling:3.3, stability:0.82, wheelieMult:1.05, rearHeight:18, rearHitThreshold:280, mass:80, audio:'assets/derbi.mp3'},
    {id:'yamaha', name:'Yamaha DT', color:'#60a5fa', acceleration:1700, maxSpeed:480, handling:3.0, stability:0.75, wheelieMult:1.25, rearHeight:22, rearHitThreshold:320, mass:85, audio:'assets/yamaha.mp3'},
    {id:'aprilia', name:'Aprilia SX', color:'#ef4444', acceleration:1900, maxSpeed:520, handling:3.7, stability:0.68, wheelieMult:1.4, rearHeight:16, rearHitThreshold:360, mass:78, audio:'assets/aprilia.mp3'},
    {id:'beta', name:'Beta RR', color:'#f97316', acceleration:1500, maxSpeed:440, handling:3.9, stability:0.9, wheelieMult:0.95, rearHeight:26, rearHitThreshold:260, mass:88, audio:'assets/beta.mp3'}
  ];

  // Load saved tuning
  const savedTuning = JSON.parse(localStorage.getItem('mopedTune') || 'null');
  if(savedTuning) {
    powerRange.value = savedTuning.power || 0;
    stabilityRange.value = savedTuning.stability || 0;
    colorPicker.value = savedTuning.color || colorPicker.value;
    exhaustSelect.value = savedTuning.exhaust || 'stock';
  }

  let selectedIndex = 0;
  let selectedMoped = mopeds[selectedIndex];

  // tuning modifiers
  let powerUpgrade = parseInt(powerRange.value) || 0;
  let stabilityUpgrade = parseInt(stabilityRange.value) || 0;
  powerLevel.textContent = powerUpgrade;
  stabLevel.textContent = stabilityUpgrade;

  // Audio: support custom file and synth fallback
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  let customAudioBuffer = null;
  let customSource = null;
  let synthOsc = null, synthGain=null, synthFilter=null;
  let synthStarted = false;

  function startSynth(){
    if(!audioCtx || synthStarted) return;
    synthOsc = audioCtx.createOscillator();
    synthGain = audioCtx.createGain();
    synthFilter = audioCtx.createBiquadFilter();
    synthOsc.type = 'sawtooth';
    synthFilter.type = 'lowpass';
    synthFilter.frequency.value = 800;
    synthGain.gain.value = 0;
    synthOsc.connect(synthFilter); synthFilter.connect(synthGain); synthGain.connect(audioCtx.destination);
    synthOsc.start();
    synthStarted = true;
  }
  function stopSynth(){
    if(!synthStarted) return;
    try{ synthOsc.stop(); }catch(e){}
    try{ synthOsc.disconnect(); synthFilter.disconnect(); synthGain.disconnect(); }catch(e){}
    synthOsc = synthFilter = synthGain = null; synthStarted = false;
  }
  function playCustomLoop(buffer, throttle){
    if(!audioCtx) return;
    if(customSource){
      try{ customSource.stop(); }catch(e){}
      try{ customSource.disconnect(); }catch(e){}
      customSource = null;
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.loop = true;
    const g = audioCtx.createGain();
    g.gain.value = clamp(throttle, 0.02, 1) * 0.9;
    src.connect(g); g.connect(audioCtx.destination);
    src.playbackRate.value = 0.8 + throttle * 1.4;
    src._gainNode = g;
    src.start();
    customSource = src;
  }

  fileInput.addEventListener('change', e=>{
    const f = e.target.files && e.target.files[0];
    if(!f || !audioCtx) { if(!audioCtx) alert('Selaimesi ei tue WebAudioContextia.'); return; }
    const r = new FileReader();
    r.onload = ev => {
      audioCtx.decodeAudioData(ev.target.result, buffer => {
        customAudioBuffer = buffer;
        if(customSource){ try{ customSource.stop(); }catch(e){} customSource = null; }
        alert('Mukautettu ääni ladattu. Aloita peli niin ääni soi.');
      }, err => { console.error(err); alert('Äänitiedoston dekoodaus epäonnistui.'); });
    };
    r.readAsArrayBuffer(f);
  });

  // Build moped UI
  function buildMopeds(){
    mopedSelectEl.innerHTML = '';
    mopeds.forEach((m,i) => {
      const d = document.createElement('div');
      d.className = 'mopedCard' + (i===selectedIndex? ' selected':'');
      d.innerHTML = `<strong>${m.name}</strong><div class="small">Top ${Math.round(m.maxSpeed)} | Acc ${Math.round(m.acceleration)}</div>`;
      d.addEventListener('click', ()=>{ selectedIndex = i; selectedMoped = mopeds[selectedIndex]; colorPicker.value = selectedMoped.color; buildMopeds(); });
      mopedSelectEl.appendChild(d);
    });
  }
  buildMopeds();

  // Save/Load tuning
  saveTuneBtn.addEventListener('click', ()=>{
    const tune = {power: parseInt(powerRange.value), stability: parseInt(stabilityRange.value), color: colorPicker.value, exhaust: exhaustSelect.value};
    localStorage.setItem('mopedTune', JSON.stringify(tune));
    alert('Tuunaukset tallennettu paikallisesti.');
  });
  loadTuneBtn.addEventListener('click', ()=>{
    const tune = JSON.parse(localStorage.getItem('mopedTune') || 'null');
    if(!tune){ alert('Ei tallennettuja tuunauksia.'); return; }
    powerRange.value = tune.power; stabilityRange.value = tune.stability; colorPicker.value = tune.color; exhaustSelect.value = tune.exhaust;
    powerUpgrade = parseInt(powerRange.value); stabilityUpgrade = parseInt(stabilityRange.value);
    powerLevel.textContent = powerUpgrade; stabLevel.textContent = stabilityUpgrade;
    alert('Tuunaukset palautettu.');
  });

  // World + player state
  const player = {
    x:140, y:H-120, w:110, h:40,
    vx:0, vy:0, angle:0, angularVel:0,
    wheelie:false, wheelieTime:0
  };
  let cameraX = 0, score = 0, best = parseInt(localStorage.getItem('mopedBest')||'0'), running=false;
  const ramps = [];
  function genRamps(){ ramps.length=0; let x=0; while(x<12000){ if(Math.random()<0.12){ const rw=80+Math.random()*200; const rh=20+Math.random()*120; const slope = (Math.random()*0.6-0.3); ramps.push({x, w:rw, h:rh, slope}); x+=rw+80+Math.random()*240; } else x+=140+Math.random()*400; } }
  genRamps();

  // Particles
  const particles = [];
  function spawnParticle(x,y,life,dx,dy,color,size){
    particles.push({x,y,dx,dy,life,max:life,color,size});
  }
  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.life -= dt;
      if(p.life <= 0){ particles.splice(i,1); continue; }
      p.x += p.dx * dt;
      p.y += p.dy * dt;
      p.dy += 400 * dt; // gravity on particles
    }
  }
  function drawParticles(ctx, camX){
    for(const p of particles){
      const alpha = p.life / p.max;
      ctx.fillStyle = hexToRgba(p.color, alpha);
      ctx.beginPath();
      ctx.arc(p.x - camX, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Parallax procedural layers
  const parallaxLayers = [
    {speed:0.16, draw: (ctx, offsetX)=>{ ctx.fillStyle='#072f3a'; for(let i=-2;i<6;i++){ const mx = i*1000 - (offsetX * 0.16 % 1000); ctx.beginPath(); ctx.moveTo(mx, H-260); ctx.lineTo(mx+220, H-420 - ((i%2)?30:0)); ctx.lineTo(mx+440, H-260); ctx.closePath(); ctx.fill(); }}},
    {speed:0.48, draw: (ctx, offsetX)=>{ ctx.fillStyle='#0b4b3f'; for(let i=-4;i<20;i++){ const tx = i*180 - (offsetX * 0.48 % 180); const h = 30 + (i%3)*10; ctx.beginPath(); ctx.moveTo(tx, H-118); ctx.lineTo(tx+12, H-150 - h); ctx.lineTo(tx+24, H-118); ctx.closePath(); ctx.fill(); }}},
    {speed:0.86, draw: (ctx, offsetX)=>{ ctx.fillStyle='#0f3940'; for(let i=-2;i<12;i++){ const bx = i*420 - (offsetX * 0.86 % 420); ctx.fillRect(bx+40, H-140 - ((i%3)*6), 50, 40 + ((i%2)?6:0)); }}}
  ];

  // Input
  const keys = {};
  window.addEventListener('keydown', e=>{
    keys[e.key.toLowerCase()]=true;
    if(!running && (e.key==='ArrowUp'||e.key===' '||e.key==='w')) startGame();
    if(e.key === ' ') e.preventDefault();
  }, {passive:false});
  window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

  // touch
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const wheelieBtn = document.getElementById('wheelieBtn');
  if(leftBtn){ leftBtn.addEventListener('touchstart', e=>{ e.preventDefault(); keys['a']=true; }); leftBtn.addEventListener('touchend', e=>{ e.preventDefault(); keys['a']=false; }); }
  if(rightBtn){ rightBtn.addEventListener('touchstart', e=>{ e.preventDefault(); keys['d']=true; }); rightBtn.addEventListener('touchend', e=>{ e.preventDefault(); keys['d']=false; }); }
  if(wheelieBtn){ wheelieBtn.addEventListener('touchstart', e=>{ e.preventDefault(); keys['arrowup']=true; }); wheelieBtn.addEventListener('touchend', e=>{ e.preventDefault(); keys['arrowup']=false; }); }

  // tuning inputs
  colorPicker.addEventListener('input', ()=>{ selectedMoped.color = colorPicker.value; buildMopeds(); });
  powerRange.addEventListener('input', ()=>{ powerUpgrade = parseInt(powerRange.value); powerLevel.textContent = powerUpgrade; });
  stabilityRange.addEventListener('input', ()=>{ stabilityUpgrade = parseInt(stabilityRange.value); stabLevel.textContent = stabilityUpgrade; });

  // helpers
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function normalizeAngle(a){ while(a < -Math.PI) a += Math.PI * 2; while(a > Math.PI) a -= Math.PI * 2; return a; }
  function hexToRgba(hex, a){ let c = hex.replace('#',''); if(c.length===3) c=c.split('').map(x=>x+x).join(''); const num=parseInt(c,16); const r=(num>>16)&255, g=(num>>8)&255, b=num&255; return `rgba(${r},${g},${b},${a})`; }

  // Start/reset
  function startGame(){
    if(audioCtx && audioCtx.state === 'suspended'){ audioCtx.resume(); }
    cameraX=0; score=0; player.x=140; player.y=H-120; player.vx=0; player.vy=0; player.angle=0; player.angularVel=0; player.wheelie=false; player.wheelieTime=0; running=true; genRamps(); particles.length=0; last = 0; loop(performance.now());
  }
  restartBtn.addEventListener('click', ()=> startGame());

  // Sound update
  function updateSound(throttle){
    if(!audioCtx) return;
    if(customAudioBuffer){
      playCustomLoop(customAudioBuffer, throttle);
      return;
    }
    startSynth();
    const base = 110 + throttle*320;
    const cutoff = 600 + throttle*1400;
    synthOsc.frequency.setTargetAtTime(base, audioCtx.currentTime, 0.02);
    synthFilter.frequency.setTargetAtTime(cutoff, audioCtx.currentTime, 0.05);
    synthGain.gain.setTargetAtTime(0.01 + throttle*0.14, audioCtx.currentTime, 0.02);
  }

  // Physics: includes vertical (vy) and rear-fender collision check
  function physicsUpdate(dt, inputs){
    selectedMoped = mopeds[selectedIndex];
    const tunedWheelieMult = selectedMoped.wheelieMult + powerUpgrade*0.22;
    const tunedStability = clamp(selectedMoped.stability + stabilityUpgrade*0.06, 0.2, 1.5);

    const forward = inputs.forward ? 1 : 0;
    const back = inputs.back ? 1 : 0;
    const move = forward - back;

    // longitudinal acceleration (force / mass)
    const force = move * selectedMoped.acceleration * (1 + powerUpgrade*0.12);
    const ax = Math.cos(player.angle) * force / selectedMoped.mass;
    const ay = Math.sin(player.angle) * force / selectedMoped.mass;
    player.vx += ax * dt;
    player.vy += ay * dt;

    // vertical gravity for jumps (simple)
    player.vy += 600 * dt; // gravity pulls down (positive y is downward)

    // ground collision (player stays near ground surface)
    // Determine ground Y at player's world X by checking ramps under cameraX+screen pos
    const worldX = player.x + cameraX;
    let groundY = H - 96; // default ground top
    for(const r of ramps){
      if(worldX >= r.x && worldX <= r.x + r.w){
        // linear ramp profile: simple triangular slope
        const t = (worldX - r.x) / r.w;
        groundY = H - 96 - r.h * Math.sin(t * Math.PI) - (r.slope * 6);
        break;
      }
    }

    // Apply drag (longitudinal)
    const speed = Math.hypot(player.vx, player.vy);
    const baseFriction = 1 - (1.1 * dt);
    const speedDrag = 1 - clamp((Math.abs(player.vx) / (selectedMoped.maxSpeed * 1.2)), 0, 0.95) * 0.75 * dt;
    player.vx *= (baseFriction * speedDrag);

    // clamp horizontal speed
    const maxS = selectedMoped.maxSpeed * (1 + powerUpgrade*0.06);
    const hv = Math.abs(player.vx);
    if(hv > maxS){ player.vx = (player.vx / hv) * maxS; }

    // turning
    const left = inputs.left ? 1 : 0;
    const right = inputs.right ? 1 : 0;
    const turn = right - left;
    const curSpeed = Math.hypot(player.vx, 0); // horizontal speed matters for turning
    const speedFactor = clamp(1 - (curSpeed / (selectedMoped.maxSpeed*1.2)), 0.12, 1.0);
    const baseTurnRate = selectedMoped.handling * (1 + stabilityUpgrade*0.06);
    const wheeliePenalty = player.wheelie ? (1 - tunedStability*0.25) : 1;
    player.angularVel = turn * baseTurnRate * speedFactor * wheeliePenalty;
    player.angle += player.angularVel * dt;

    // Align orientation to velocity when not actively turning (soft)
    if(Math.abs(turn) < 0.001 && Math.abs(player.vx) > 40){
      const target = Math.atan2(0, player.vx); // face horizontally in direction of vx
      let diff = normalizeAngle(target - player.angle);
      player.angle += diff * clamp(dt * 2.5, 0, 1);
    }

    // Wheelie logic: vertical lift when throttle and speed
    if(forward && Math.abs(player.vx) > 60){
      if(!player.wheelie){ player.wheelie = true; player.wheelieTime = 0; }
      player.wheelieTime += dt;
      // Raise front: simulate by lowering ground clearance of rear relative to front
      // Add small upward offset to simulate lift off ground
      if(Math.random() < dt * 8) spawnParticle(player.x + 20, groundY - 8, 0.6, -30 - Math.random()*20, -20 - Math.random()*10, '#bba38f', 3 + Math.random()*3);
      // reduce lateral control while wheelie
      player.angle += ((right?0.012:0) + (left?-0.012:0) - (1 - tunedStability)*0.06) * dt * 8;
    } else {
      if(player.wheelie && player.wheelieTime > 0.2){
        // landing particles
        for(let i=0;i<6;i++) spawnParticle(player.x - 10 + i*6, groundY - 6, 0.6 + Math.random()*0.6, Math.random()*40-20, -20 - Math.random()*10, '#999', 2 + Math.random()*3);
      }
      player.wheelie = false;
      player.wheelieTime = 0;
      // relax angle
      player.angle *= Math.pow(0.85, dt*60);
    }

    // simulate vertical landing: if player would go below groundY, treat as landing impact
    const playerBottomY = groundY; // desired bottom y-level for player's wheels
    // compute rear-fender world height: rearHeight is distance from wheels to rear fender pivot (approx)
    const rearWorldHeight = playerBottomY - (selectedMoped.rearHeight) - (player.y - playerBottomY); // how high rear is relative to ground
    // If player is above ground, apply vertical motion; if below, snap and evaluate impact
    if(player.y + player.vy * dt > playerBottomY){
      // landing: compute impact vertical speed (vy downward positive)
      const impactVy = player.vy;
      // snap to ground
      player.y = playerBottomY;
      player.vy = 0;
      // Evaluate rear-fender collision: if rearWorldHeight is low (near ground) AND impactVy exceeds threshold OR angle too tilted, instant crash.
      // rearHitThreshold and rearHeight tuned per moped
      const rearHit = (rearWorldHeight < selectedMoped.rearHeight * 0.5) && (impactVy > selectedMoped.rearHitThreshold);
      // Also check big angular tilt on landing
      const badAngle = Math.abs(player.angle) > 1.2;
      if(rearHit || badAngle){
        // immediate crash
        onCrash('Takalokari osui maahan voimakkaasti tai pala liian vino (rearHit:'+rearHit+', badAngle:'+badAngle+')');
        return; // stop physics/render further
      } else {
        // successful landing: small bounce
        player.vy = -impactVy * 0.25;
        spawnParticle(player.x + 12, player.y - 8, 0.6, (Math.random()-0.5)*40, -40 - Math.random()*30, '#bdbdbd', 3);
      }
    } else {
      // in-air
      player.y += player.vy * dt;
    }

    // update horizontal position
    player.x += player.vx * dt;

    // clamp within world bounds (soft)
    player.x = clamp(player.x, 40, 12000 - 40);
  }

  // Crash handler: stops game, shows message
  function onCrash(reason){
    running=false;
    stopSynth();
    if(customSource){ try{ customSource.stop(); }catch(e){} customSource=null; }
    if(score > best){ best = Math.floor(score); localStorage.setItem('mopedBest', best); }
    // small explosion particles
    for(let i=0;i<18;i++) spawnParticle(player.x + Math.random()*40-20, player.y - 10 + Math.random()*20, 0.8 + Math.random()*0.8, Math.random()*300-150, -100 + Math.random()*80, '#ffb86b', 3 + Math.random()*4);
    setTimeout(()=>{ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='22px system-ui'; ctx.textAlign='center'; ctx.fillText('Kaatui! Pisteet: '+Math.floor(score), W/2, H/2 - 8); ctx.font='14px system-ui'; ctx.fillText('Syy: '+reason, W/2, H/2 + 18); ctx.fillText('Tallenna tuunaukset tai paina Aloita', W/2, H/2 + 42); },200);
  }

  // Main loop
  let last=0;
  function loop(ts){
    if(!running) return;
    if(!last) last=ts; const dtms = Math.min(50, ts-last); last = ts; const dt = dtms/1000;

    selectedMoped = mopeds[selectedIndex];
    const tunedColor = colorPicker.value || selectedMoped.color;

    // inputs
    const left = keys['arrowleft'] || keys['a'];
    const right = keys['arrowright'] || keys['d'];
    const up = keys['arrowup'] || keys['w'] || keys[' '];
    const down = keys['s'] || keys['arrowdown'];
    const inputs = {forward: up, back: down, left: left, right: right};

    physicsUpdate(dt, inputs);
    updateParticles(dt);

    // scoring wheelie
    if(player.wheelie){
      const angleFactor = Math.max(0, 1 - Math.abs(player.angle) / 1.0);
      const exhaust = exhaustSelect.value;
      const exhaustMul = exhaust === 'stock' ? 0.85 : (exhaust === 'sport' ? 1.05 : 1.2);
      const pts = angleFactor * (selectedMoped.wheelieMult + powerUpgrade*0.22) * exhaustMul * dt * 40;
      score += pts;
    }

    // camera smoothing to follow player.x
    const targetCam = clamp(player.x - W*0.35, 0, 12000);
    cameraX += (targetCam - cameraX) * clamp(dt * 4, 0, 1);

    // throttle for sound
    const throttle = clamp(Math.abs(player.vx) / (selectedMoped.maxSpeed * 1.1), 0, 1);
    updateSound(throttle * (1 + powerUpgrade*0.12));

    scoreEl.textContent = Math.floor(score);

    // Render
    ctx.clearRect(0,0,W,H);
    const sky = ctx.createLinearGradient(0,0,0,H); sky.addColorStop(0,'#4fb2ff'); sky.addColorStop(0.7,'#9bd1ff'); sky.addColorStop(1,'#fff'); ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

    // parallax
    parallaxLayers.forEach(layer => { layer.draw(ctx, cameraX); });

    // ground
    ctx.fillStyle='#06202b'; ctx.fillRect(0,H-96,W,96);
    // repeating shadows
    ctx.save(); ctx.translate(-cameraX % W,0);
    for(let i=-1;i<6;i++){
      ctx.fillStyle='rgba(7,36,45,0.9)'; ctx.beginPath(); ctx.ellipse(i*W+200, H-40, 220, 80, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(i*W+640, H-40, 240, 90, 0, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // ramps
    for(const r of ramps){
      const rx = r.x - cameraX;
      if(rx + r.w < -200 || rx > W + 200) continue;
      ctx.fillStyle='#2b5563'; ctx.fillRect(rx, H-96 - r.h, r.w, r.h);
      ctx.fillStyle='#2e6b79'; ctx.fillRect(rx, H-96 - r.h, r.w, 6);
    }

    // particles
    drawParticles(ctx, cameraX);

    // draw player: compute screenX relative to camera
    const screenX = clamp(player.x - cameraX, 80, W - 140);
    // shadow
    ctx.fillStyle='rgba(0,0,0,0.24)'; ctx.beginPath(); ctx.ellipse(screenX+44, H-40, 56, 14, 0, 0, Math.PI*2); ctx.fill();

    // draw bike body (procedural)
    ctx.save();
    ctx.translate(screenX+44, player.y+12);
    ctx.rotate(player.angle);

    const tunedColorHex = colorPicker.value || selectedMoped.color;
    ctx.fillStyle = tunedColorHex;
    ctx.beginPath();
    ctx.moveTo(-48, 10);
    ctx.quadraticCurveTo(-28, -18, 0, -16);
    ctx.quadraticCurveTo(32, -14, 48, 8);
    ctx.lineTo(48, 14);
    ctx.quadraticCurveTo(20, 26, -48, 14);
    ctx.closePath();
    ctx.fill();

    // model-specific visuals
    const model = selectedMoped.id;
    if(model === 'derbi'){
      ctx.fillStyle = shadeColor(tunedColorHex, -12);
      ctx.fillRect(-20, -12, 40, 8);
      ctx.fillStyle = '#111827'; ctx.fillRect(-10, -18, 20, 6);
      ctx.fillStyle = '#ffffff55'; ctx.fillRect(-46, -2, 92, 4);
    } else if(model === 'yamaha'){
      ctx.fillStyle = '#21342a';
      ctx.fillRect(-44, -6, 18, 8);
      ctx.fillRect(26, -4, 18, 8);
      ctx.fillStyle = '#00000025';
      for(let i=-36;i<=36;i+=12) ctx.fillRect(i, 4, 6, 2);
    } else if(model === 'aprilia'){
      ctx.fillStyle = '#111827'; ctx.fillRect(-8, -18, 16, 6);
      ctx.fillStyle = '#ffe27a'; ctx.fillRect(-40, -4, 20, 6);
      ctx.fillStyle = '#ffffff44'; ctx.beginPath(); ctx.arc(18, -4, 10, 0, Math.PI*2); ctx.fill();
    } else if(model === 'beta'){
      ctx.fillStyle = '#0b1f24'; ctx.fillRect(-30, -6, 12, 10); ctx.fillRect(12, -10, 8, 12);
      ctx.fillStyle = '#ffffff22'; ctx.fillRect(-10, -16, 20, 4);
    }

    // wheels
    ctx.fillStyle='#06202a';
    ctx.beginPath(); ctx.arc(-28, 18, 16, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(28, 18, 16, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#111827';
    ctx.beginPath(); ctx.arc(-28, 18, 8, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(28, 18, 8, 0, Math.PI*2); ctx.fill();

    // rear-fender visual (important: collide check uses selectedMoped.rearHeight)
    ctx.fillStyle = '#0c1114';
    ctx.fillRect(-34, 8, 18, 6); // front wheel fender
    ctx.fillRect(26, 8 - selectedMoped.rearHeight/10, 18, 6); // rear fender small visual

    // exhaust
    ctx.fillStyle = exhaustSelect.value === 'racing' ? '#fed7aa' : (exhaustSelect.value === 'sport' ? '#fca5a5' : '#cbd5e1');
    ctx.fillRect(34, -2, 18, 6);

    ctx.restore();

    // HUD / UI
    ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(10,10,360,92);
    ctx.fillStyle='#fff'; ctx.font='16px system-ui'; ctx.textAlign='left'; ctx.fillText(selectedMoped.name, 18, 36);
    ctx.font='14px system-ui'; ctx.fillText('Paras: '+best, 18, 60);
    ctx.font='12px system-ui'; ctx.fillText('Nopeus: '+Math.round(Math.abs(player.vx)), 18, 82);
    ctx.textAlign='right';
    ctx.font='13px system-ui';
    ctx.fillText('Wheelie: '+(player.wheelie ? (Math.floor(player.wheelieTime*10)/10)+'s' : '0s'), W-18, 26);
    ctx.fillText('Power: '+powerUpgrade, W-18, 46);
    ctx.fillText('Stab: '+stabilityUpgrade, W-18, 66);

    requestAnimationFrame(loop);
  }

  // small color utility
  function shadeColor(hex, percent) {
    let c = hex.replace('#','');
    if(c.length === 3) c = c.split('').map(x=>x+x).join('');
    const num = parseInt(c,16), amt = Math.round(2.55 * percent);
    let R = clamp((num >> 16) + amt, 0, 255);
    let G = clamp(((num >> 8) & 0x00FF) + amt, 0, 255);
    let B = clamp((num & 0x0000FF) + amt, 0, 255);
    return '#' + ((1<<24) + (R<<16) + (G<<8) + B).toString(16).slice(1);
  }

  // initial draw
  ctx.fillStyle='#071025'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='18px system-ui'; ctx.textAlign='center'; ctx.fillText('Valitse mopedi, säädä väri/putki ja paina Aloita', W/2, H/2 - 6);
  buildMopeds();

  // autosave tuning
  function autoSaveTune(){ const tune = {power: parseInt(powerRange.value), stability: parseInt(stabilityRange.value), color: colorPicker.value, exhaust: exhaustSelect.value}; localStorage.setItem('mopedTune', JSON.stringify(tune)); }
  powerRange.addEventListener('change', autoSaveTune);
  stabilityRange.addEventListener('change', autoSaveTune);
  colorPicker.addEventListener('change', autoSaveTune);
  exhaustSelect.addEventListener('change', autoSaveTune);

  // expose start for convenience
  window.__startMopedGame = startGame;

})();
</script>
</body>
</html>
